<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>USA Trees — Overview Dashboard</title>
  <style>
    :root { --fg:#111; --bg:#fafafa; --muted:#666; --card:#fff; --border:#eee; --sel:#111; }
    * { box-sizing: border-box; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:var(--bg); color:var(--fg); margin:0; }
    header { display:flex; align-items:center; justify-content:space-between; gap:.75rem; padding:16px 20px; border-bottom:1px solid var(--border); background:var(--card); position:sticky; top:0; z-index:10; }
    h1 { margin:0; font-size:18px; letter-spacing:.01em; }
    main { padding:16px; }
    .intro { max-width: 1100px; margin: 0 auto 14px; background:var(--card); border:1px solid var(--border); border-radius:14px; padding:14px; box-shadow:0 2px 12px rgba(0,0,0,.04); }
    .intro p { margin: 6px 0; color:#333; font-size:14px; line-height:1.45; }
    .controls { display:flex; flex-wrap:wrap; align-items:center; gap:.5rem .75rem; margin-top:8px; }
    label { font-size:13px; color:#333; display:flex; align-items:center; gap:.4rem; }
    select, input[type="checkbox"] { cursor:pointer; }
    select { padding:6px 8px; border-radius:10px; border:1px solid #ddd; background:#fff; font-size:13px; }
    .pill { display:inline-flex; align-items:center; gap:.35rem; border:1px solid #ddd; padding:6px 8px; border-radius:999px; background:#fff; font-size:12px; }

    .grid { display:grid; grid-template-columns: 1.12fr 1fr; grid-template-rows: auto auto; gap:16px; align-items:start; max-width: 1200px; margin: 0 auto; }
    .panel { background:var(--card); border:1px solid var(--border); border-radius:14px; padding:12px; box-shadow:0 2px 12px rgba(0,0,0,.04); }
    .panel h2 { margin:0 0 8px; font-size:15px; letter-spacing:.02em; color:#444; }

    svg { width:100%; height:auto; display:block; }
    .state { stroke:#fff; stroke-width:0.6; transition: fill .15s, opacity .15s; }
    .state.hovered { stroke:#111; stroke-width:1; }
    .state.dimmed { opacity:.25; }

    .dot { fill:#555; opacity:.9; transition: r .1s, opacity .15s, stroke-width .1s; }
    .dot.hovered { stroke:#111; stroke-width:1.5; }
    .dot.dimmed { opacity:.2; }

    .axis text { font-size:11px; fill:#333; }
    .axis path, .axis line { stroke:#ccc; shape-rendering: crispEdges; }

    .legend { margin-top:8px; }
    .legend .title { font-size:12px; font-weight:600; margin-bottom:6px; }
    .legend .bar { display:flex; height:10px; border:1px solid #ddd; border-radius:4px; overflow:hidden; }
    .legend .seg { flex:1; }
    .legend .ticks { display:flex; justify-content:space-between; font-size:11px; color:#333; margin-top:4px; }

    .tooltip { position:fixed; pointer-events:none; background:#fff; border:1px solid #ddd; border-radius:8px; padding:8px 10px; box-shadow:0 4px 16px rgba(0,0,0,.08); font-size:12px; opacity:0; transition:opacity .1s; }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
    .kpi { display:flex; gap:12px; flex-wrap:wrap; font-size:12px; color:#333; margin-top:4px; }
    .kpi span { background:#f7f7f7; border:1px solid #eee; padding:4px 6px; border-radius:8px; }
  </style>
</head>
<body>
  <header>
    <h1>USA Trees — Overview Dashboard</h1>
  </header>

  <main>
    <!-- Intro / How-to -->
    <section class="intro" aria-label="Dashboard introduction">
      <p><strong>What you’re seeing:</strong> a linked overview of U.S. state-level tree & environment metrics. The <em>map</em> colors states by a chosen metric. The <em>scatter</em> compares any two metrics you pick. The <em>distribution</em> (histogram) shows the spread of the map metric.</p>
      <p><strong>How to use:</strong> choose a <em>Map metric</em> and X/Y for the scatter. Hover a state or dot to see details and highlight the same state across views. Drag on the scatter to brush a subset — brushed states remain bright on the map and the histogram dims other bins. Toggle log scales if values span large ranges. Clear a brush by clicking an empty area.</p>
      <p><strong>Dataset:</strong> AI generated by ChatGPT5</p>

      <div class="controls">
        <label>Map metric <select id="metricMap"></select></label>
        <label>X <select id="metricX"></select></label>
        <label>Y <select id="metricY"></select></label>
        <span class="pill"><label style="gap:.3rem;"><input id="logX" type="checkbox"> log X</label></span>
        <span class="pill"><label style="gap:.3rem;"><input id="logY" type="checkbox"> log Y</label></span>
      </div>
    </section>

    <!-- Layout -->
    <div class="grid">
      <!-- Map (tall) -->
      <section class="panel" style="grid-row: 1 / span 2;">
        <h2>US Map</h2>
        <svg id="map" viewBox="0 0 975 610" aria-label="United States map"></svg>
        <div id="legend" class="legend"></div>
        <p class="hint">Color scale uses quantiles of the selected <em>Map metric</em>. Brush on the scatter to filter; hover anywhere to link tooltips.</p>
      </section>

      <!-- Scatter -->
      <section class="panel">
        <h2>Scatter</h2>
        <svg id="scatter" viewBox="0 0 650 360" aria-label="Scatter plot"></svg>
        <div class="kpi" id="scatter-kpi"></div>
      </section>

      <!-- Distribution -->
      <section class="panel">
        <h2>Distribution of Map Metric</h2>
        <svg id="hist" viewBox="0 0 650 320" aria-label="Histogram of map metric"></svg>
      </section>
    </div>
  </main>

  <div id="tooltip" class="tooltip" role="status" aria-live="polite"></div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>

  <!-- Dashboard script (adapted from your Iteration 3) -->
  <script>
  (function(){
    // ----- Constants & helpers -----
    const GREEN = ['#f7fcf5','#e5f5e0','#c7e9c0','#a1d99b','#74c476','#41ab5d','#238b45','#005a32'];
    const fmt = { num: d3.format(".3~g"), pct1: d3.format(".1f") };

    const NAME_TO_CODE = {"Alabama":"AL","Alaska":"AK","Arizona":"AZ","Arkansas":"AR","California":"CA","Colorado":"CO","Connecticut":"CT","Delaware":"DE","District of Columbia":"DC","Florida":"FL","Georgia":"GA","Hawaii":"HI","Idaho":"ID","Illinois":"IL","Indiana":"IN","Iowa":"IA","Kansas":"KS","Kentucky":"KY","Louisiana":"LA","Maine":"ME","Maryland":"MD","Massachusetts":"MA","Michigan":"MI","Minnesota":"MN","Mississippi":"MS","Missouri":"MO","Montana":"MT","Nebraska":"NE","Nevada":"NV","New Hampshire":"NH","New Jersey":"NJ","New Mexico":"NM","New York":"NY","North Carolina":"NC","North Dakota":"ND","Ohio":"OH","Oklahoma":"OK","Oregon":"OR","Pennsylvania":"PA","Rhode Island":"RI","South Carolina":"SC","South Dakota":"SD","Tennessee":"TN","Texas":"TX","Utah":"UT","Vermont":"VT","Virginia":"VA","Washington":"WA","West Virginia":"WV","Wisconsin":"WI","Wyoming":"WY"};

    // DOM
    const selMap = document.getElementById('metricMap');
    const selX = document.getElementById('metricX');
    const selY = document.getElementById('metricY');
    const logX = document.getElementById('logX');
    const logY = document.getElementById('logY');

    const tooltip = d3.select('#tooltip');
    const legend = d3.select('#legend');

    // Map set-up
    const Wm=975, Hm=610, projection=d3.geoAlbersUsa().translate([Wm/2,Hm/2]).scale(1280), path=d3.geoPath(projection);
    const svgMap=d3.select('#map'), gMap=svgMap.append('g');

    // Scatter set-up
    const ScW=650, ScH=360, ScM={t:20,r:16,b:36,l:44};
    const svgScatter=d3.select('#scatter'), scInner=svgScatter.append('g').attr('transform',`translate(${ScM.l},${ScM.t})`);
    const scXaxis=scInner.append('g').attr('class','axis').attr('transform',`translate(0,${ScH-ScM.t-ScM.b})`);
    const scYaxis=scInner.append('g').attr('class','axis');
    const scXlabel=svgScatter.append('text').attr('x',ScM.l+(ScW-ScM.l-ScM.r)/2).attr('y',ScH-6).attr('text-anchor','middle').attr('font-size',12).attr('fill','#333');
    const scYlabel=svgScatter.append('text').attr('transform',`translate(12,${ScM.t+(ScH-ScM.t-ScM.b)/2}) rotate(-90)`).attr('text-anchor','middle').attr('font-size',12).attr('fill','#333');
    const scDots=scInner.append('g');
    const brush=d3.brush().extent([[0,0],[ScW-ScM.l-ScM.r,ScH-ScM.t-ScM.b]]).on('brush end', brushed);
    scInner.append('g').attr('class','brush').call(brush);

    // Histogram set-up
    const HsW=650, HsH=320, HsM={t:18,r:16,b:36,l:40};
    const svgHist=d3.select('#hist'), hsInner=svgHist.append('g').attr('transform',`translate(${HsM.l},${HsM.t})`);
    const hsXaxis=hsInner.append('g').attr('class','axis').attr('transform',`translate(0,${HsH-HsM.t-HsM.b})`);
    const hsYaxis=hsInner.append('g').attr('class','axis');
    const hsBars=hsInner.append('g');
    const hsMarker=hsInner.append('line').attr('y1',0).attr('y2',HsH-HsM.t-HsM.b).attr('stroke','#111').attr('stroke-width',1.2).attr('opacity',0);

    // State
    let hovered=null, brushedSet=null, states=[], rows=[], numericCols=[], labels={}, types={};

    // Load topo + CSV
    Promise.all([
      d3.json('https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json'),
      d3.csv('data/trees.csv', r => {
        const o={}; for (const [k,v] of Object.entries(r)) o[k.trim().toLowerCase()] = v;
        return o;
      })
    ]).then(([us, raw])=>{
      // Normalize rows
      rows = raw.map(r=>{
        const name = (r.state || '').trim();
        let code = (r.code || '').trim().toUpperCase();
        if (!code && name) code = NAME_TO_CODE[name] || '';
        const out = {...r, _name:name, _code:code};
        for (const k of Object.keys(out)) {
          if (k==='state'||k==='code'||k==='_name'||k==='_code') continue;
          const n = +String(out[k]).replace(/[,\s%]/g,'');
          out[k] = Number.isFinite(n) ? n : NaN;
        }
        return out;
      });

      // Numeric columns
      const skip = new Set(['state','code','_name','_code']);
      const allKeys = Array.from(new Set(rows.flatMap(r=>Object.keys(r)))).filter(k=>!skip.has(k));
      numericCols = allKeys.filter(k => rows.some(r => Number.isFinite(r[k])));
      labels = Object.fromEntries(numericCols.map(k => [k, k.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase())]));
      types  = Object.fromEntries(numericCols.map(k => [k, k.endsWith('_pct') ? 'pct' : 'num']));

      // Dropdowns
      const opt = k => `<option value="${k}">${labels[k]}</option>`;
      selMap.innerHTML = numericCols.map(opt).join('');
      selX.innerHTML   = numericCols.map(opt).join('');
      selY.innerHTML   = numericCols.map(opt).join('');

      // Defaults
      const defMap = numericCols.includes('canopy_cover_pct') ? 'canopy_cover_pct' : numericCols[0];
      const defX   = numericCols.includes('protected_area_trees_pct') ? 'protected_area_trees_pct' : numericCols[0];
      const defY   = numericCols.includes('reforestation_rate_pct') ? 'reforestation_rate_pct' : (numericCols[1]||numericCols[0]);
      selMap.value = defMap; selX.value = defX; selY.value = defY;

      // Build map features & join
      states = topojson.feature(us, us.objects.states).features;
      const borders = topojson.mesh(us, us.objects.states, (a,b)=>a!==b);
      const byName = new Map(rows.map(r => [r._name, r]));
      const byCode = new Map(rows.map(r => [r._code, r]));
      states.forEach(f => {
        const name = f.properties.name;
        const code = NAME_TO_CODE[name] || '';
        f.data = byName.get(name) || byCode.get(code) || null;
      });

      // Draw base map
      const paths = gMap.selectAll('.state')
        .data(states)
        .join('path')
        .attr('class','state')
        .attr('d', path)
        .attr('fill', '#eee')
        .on('mousemove', (event, d) => setHover(d.properties.name, event))
        .on('mouseleave', () => setHover(null, null));

      svgMap.append('path')
        .attr('d', path(borders))
        .attr('fill','none')
        .attr('stroke','#fff')
        .attr('stroke-width',0.6)
        .attr('pointer-events','none');

      // Wire controls
      [selMap, selX, selY, logX, logY].forEach(el => el.addEventListener('change', updateAll));

      // First render
      updateAll();
    }).catch(err=>{
      console.error(err);
      alert('Could not load map or CSV. Make sure you are serving files over http and data/trees.csv exists.');
    });

    // ----- Rendering -----
    function updateAll(){
      if (!states.length || !numericCols.length) return;

      // Map colors
      const mMap = selMap.value;
      const valsMap = states.map(s => s.data?.[mMap]).filter(Number.isFinite);
      const color = d3.scaleQuantile().domain(valsMap).range(GREEN);

      gMap.selectAll('.state')
        .attr('fill', d => Number.isFinite(d.data?.[mMap]) ? color(d.data[mMap]) : '#eee')
        .classed('hovered', d => hovered && d.properties.name === hovered)
        .classed('dimmed', d => brushedSet && !brushedSet.has(d.properties.name));

      drawLegend(valsMap, color, labels[mMap]);

      // Scatter
      const mX = selX.value, mY = selY.value;
      const data = states
        .map(s => ({ name:s.properties.name, x:s.data?.[mX], y:s.data?.[mY], map:s.data?.[mMap] }))
        .filter(d => Number.isFinite(d.x) && Number.isFinite(d.y));

      const xVals = data.map(d=>d.x), yVals = data.map(d=>d.y);
      const xScale = (logX.checked ? d3.scaleLog() : d3.scaleLinear())
                      .domain(niceDomain(xVals, logX.checked))
                      .range([0, ScW-ScM.l-ScM.r]);
      const yScale = (logY.checked ? d3.scaleLog() : d3.scaleLinear())
                      .domain(niceDomain(yVals, logY.checked))
                      .range([ScH-ScM.t-ScM.b, 0]).nice();

      scXaxis.call(d3.axisBottom(xScale).ticks(6, logX.checked ? ".1s" : null));
      scYaxis.call(d3.axisLeft(yScale).ticks(6, logY.checked ? ".1s" : null));
      scXlabel.text(labels[mX]); scYlabel.text(labels[mY]);

      const dots = scDots.selectAll('circle').data(data, d=>d.name);
      dots.enter().append('circle').attr('class','dot').attr('r',3.8)
          .merge(dots)
          .attr('cx', d => xScale(d.x))
          .attr('cy', d => yScale(d.y))
          .attr('fill', d => Number.isFinite(d.map) ? color(d.map) : '#bbb')
          .classed('hovered', d => hovered && d.name === hovered)
          .classed('dimmed', d => brushedSet && !brushedSet.has(d.name))
          .on('mousemove', (event,d)=> setHover(d.name, event))
          .on('mouseleave', ()=> setHover(null, null));
      dots.exit().remove();

      // KPIs (Pearson r)
      const corr = pearson(xVals, yVals);
      const kpi = d3.select('#scatter-kpi').html('');
      kpi.append('span').text(`N = ${data.length}`);
      if (Number.isFinite(corr)) kpi.append('span').text(`Pearson r ≈ ${fmt.num(corr)}`);

      // Histogram
      drawHist(valsMap, color, mMap);

      if (hovered){
        const st = states.find(s => s.properties.name === hovered);
        const v = st?.data?.[mMap];
        if (Number.isFinite(v)) setHistMarker(v); else clearHistMarker();
      } else clearHistMarker();
    }

    function drawLegend(values, color, title){
      legend.selectAll('*').remove();
      if (!values.length) return;
      const bins=[d3.min(values), ...color.quantiles(), d3.max(values)];
      const wrap=legend.append('div').attr('class','legend');
      wrap.append('div').attr('class','title').text(title);
      const bar=wrap.append('div').attr('class','bar');
      for(let i=0;i<bins.length-1;i++){ bar.append('span').attr('class','seg').style('background', color((bins[i]+bins[i+1])/2)); }
      const ticks=wrap.append('div').attr('class','ticks');
      bins.forEach(b=> ticks.append('span').text(fmt.num(b)));
    }

    function drawHist(values, color, metricKey){
      const w=HsW-HsM.l-HsM.r, h=HsH-HsM.t-HsM.b;
      hsBars.selectAll('*').remove();
      if (!values.length) return;
      const x=d3.scaleLinear().domain(d3.extent(values)).nice().range([0,w]);
      const bins=d3.bin().domain(x.domain()).thresholds(12)(values);
      const y=d3.scaleLinear().domain([0, d3.max(bins, d=>d.length)||1]).nice().range([h,0]);

      const bars=hsBars.selectAll('g').data(bins).join('g').attr('transform',d=>`translate(${x(d.x0)}, ${y(d.length)})`);
      bars.append('rect')
        .attr('x',0).attr('y',0)
        .attr('width',d=>Math.max(0, x(d.x1)-x(d.x0)-1))
        .attr('height',d=>h-y(d.length))
        .attr('fill',d=>color((d.x0+d.x1)/2))
        .attr('opacity', d=>{
          if(!brushedSet) return 0.9;
          return brushedSetHasInBin(d.x0,d.x1,metricKey) ? 0.95 : 0.25;
        });

      hsXaxis.call(d3.axisBottom(x).ticks(6));
      hsYaxis.call(d3.axisLeft(y).ticks(4));
      hsBars.node().__xScale = x;
    }

    // Brushing
    function brushed({selection}){
      if(!selection){ brushedSet=null; updateAll(); return; }
      const [[x0,y0],[x1,y1]] = selection;
      const mX=selX.value, mY=selY.value;

      // Build scales to interpret pixel box
      const sample = states.map(s=>({name:s.properties.name,x:s.data?.[mX],y:s.data?.[mY]})).filter(d=>Number.isFinite(d.x)&&Number.isFinite(d.y));
      const xScale=(logX.checked?d3.scaleLog():d3.scaleLinear()).domain(niceDomain(sample.map(d=>d.x),logX.checked)).range([0, ScW-ScM.l-ScM.r]);
      const yScale=(logY.checked?d3.scaleLog():d3.scaleLinear()).domain(niceDomain(sample.map(d=>d.y),logY.checked)).range([ScH-ScM.t-ScM.b,0]);

      brushedSet=new Set(sample.filter(d=>{const cx=xScale(d.x), cy=yScale(d.y); return cx>=x0 && cx<=x1 && cy>=y0 && cy<=y1;}).map(d=>d.name));
      updateAll();
    }
    function brushedSetHasInBin(x0,x1,metricKey){
      if(!brushedSet) return true;
      return states.some(s=>{
        if(!brushedSet.has(s.properties.name)) return false;
        const v=s.data?.[metricKey];
        return Number.isFinite(v) && v>=x0 && v<=x1;
      });
    }

    // Hover linking
    function setHover(name, event){
      hovered=name;
      gMap.selectAll('.state').classed('hovered', d=> hovered && d.properties.name===hovered);
      scDots.selectAll('.dot').classed('hovered', d=> hovered && d.name===hovered);

      if (hovered){
        const st=states.find(s=>s.properties.name===hovered);
        const parts=[`<strong>${hovered}</strong>`];
        for(const key of [selMap.value, selX.value, selY.value]){
          const t = types[key]==='pct' ? (v=>fmt.pct1(v)+'%') : (v=>fmt.num(v));
          parts.push(`${labels[key]}: ${Number.isFinite(st?.data?.[key]) ? t(st.data[key]) : 'N/A'}`);
        }
        tooltip.style('opacity',1)
          .html(parts.join('<br>'))
          .style('left',(event.clientX+14)+'px')
          .style('top',(event.clientY-24)+'px');

        const v=st?.data?.[selMap.value]; if(Number.isFinite(v)) setHistMarker(v); else clearHistMarker();
      } else {
        tooltip.style('opacity',0);
        clearHistMarker();
      }
    }
    function setHistMarker(value){
      const x=hsBars.node().__xScale; if(!x||!Number.isFinite(value)) return;
      hsMarker.attr('x1',x(value)).attr('x2',x(value)).attr('opacity',1);
    }
    function clearHistMarker(){ hsMarker.attr('opacity',0); }

    // Utils
    function niceDomain(vals, log=false){
      const arr=vals.filter(Number.isFinite); if(!arr.length) return [1,10];
      if(log){ const minPos=d3.min(arr.filter(v=>v>0)); return [Math.max(minPos*0.9,1e-6), d3.max(arr)*1.05]; }
      const e=d3.extent(arr); const pad=(e[1]-e[0])*0.06; return [e[0]-pad, e[1]+pad];
    }
    function pearson(xs,ys){
      const n=Math.min(xs.length, ys.length); if(!n) return NaN;
      const mx=d3.mean(xs), my=d3.mean(ys);
      let num=0, dx=0, dy=0;
      for(let i=0;i<n;i++){ const a=xs[i]-mx, b=ys[i]-my; num+=a*b; dx+=a*a; dy+=b*b; }
      return (dx>0 && dy>0) ? num/Math.sqrt(dx*dy) : NaN;
    }
  })();
  </script>
</body>
</html>
